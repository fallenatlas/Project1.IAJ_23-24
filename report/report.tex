\documentclass{article}
\usepackage{hyperref}
\usepackage[a4paper, total={7.4in, 10in}]{geometry}

\begin{titlepage}
  \title{Report First Project IAJ}
  \author{João Vitór
  \and Sebastião Carvalho
  \and Tiago Antunes}
  \date{2023-09-21}
\end{titlepage}

\begin{document}
  \maketitle
  \tableofcontents
  \section{Introduction}
  The goal of this project was to create different levels of path finding algorithms, and compare their performance.\\
  We compared 4 differente algorithms: Basic A*(unordered list for open set, unordered list for closed set), Basic A* but using tiebreaking 
  (unordered list for open set, unordered list for closed set), NodeArray A* (NodeArray for open and closed set) 
  and NodeArray A* with Goal Bounding.\\
  \newpage
  \section{Basic A*}
  \subsection{Algorithm}
  The A* is a search algorithm that uses a heuristic to find the best path between 2 nodes. Even though it's a basic algorithm, it shows relatively good 
  performance when compared to other algorithms like djikstra. Despite being a basic algorithm, it's performance can be improved by using better data structures,
  or using other optimizations like we're going to show in the next sections.\\
  \subsection{Data}
  \begin{table}[h!]
      \parbox{.45\linewidth}{
        \centering
        \caption{Basic A* performance (Path 1)}
        \label{tab:tableA*1}
        \begin{tabular}{c|c|c}
          \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
          \hline
          A*Pathfinding.Search  & 1 & 10181.85\\
          GetBestAndRemove & 1904 & 44.09\\
          AddToOpen & 1954 & 1.82\\
          SearchInOpen & 18564 & 269.64\\
          RemoveFromOpen & 0 & 0\\
          Replace & 0 & 0\\
          AddToClosed & 1904  & 1.45\\
          SearchInClosed & 18460 & 9710.25\\
          RemoveFromClosed & 0 & 0\\
        \end{tabular}
      }
      \hfil
      \parbox{.45\linewidth}{
        \centering
        \caption{Basic A* performance (Path 2)}
        \label{tab:tableA*2}
        \begin{tabular}{c|c|c}
          \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
          \hline
          A*Pathfinding.Search  & 1 & 21432.88\\
          GetBestAndRemove & 2890 & 114.64\\
          AddToOpen & 3020 & 2.54\\
          SearchInOpen & 28291 & 759.53\\
          RemoveFromOpen & 0 & 0\\
          Replace & 0 & 0\\
          AddToClosed & 2890  & 1.76\\
          SearchInClosed & 27990 & 20319.63\\
          RemoveFromClosed & 0 & 0\\
        \end{tabular}
      }
  \end{table}
  \begin{table}[h!]
    \parbox{.45\linewidth}{
        \centering
        \caption{Basic A* grid information (Path 1)}
        \label{tab:tableA*Grid1}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          1904 & 0.02 & 77\\
        \end{tabular}
    }
    \hfil
    \parbox{.45\linewidth}{
        \centering
        \caption{Basic A* grid information (Path 2)}
        \label{tab:tableA*Grid2}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          2889 & 0.02 & 133\\
        \end{tabular}
    }
  \end{table}

  \section{Basic A* with tiebraking}
  \subsection{Algorithm}
  This algorithm is basically the previous one, but we use tiebraking to break ties between nodes with the same f value. This way, it makes 
  for better ordering of the nodes in the open set, and we can get the best node faster. When 2 nodes have the same f value, 
  we use order the nodes by smallest h value. This way we first pick the node that is closer to the goal.\\
  \subsection{Data}
  \begin{table}[h!]
      \parbox{.45\linewidth}{
        \centering
        \caption{Basic A* with tiebraking performance (Path 1)}
        \label{tab:tableTieBraking1}
        \begin{tabular}{c|c|c}
          \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
          \hline
          A*Pathfinding.Search  & 1 & 10029.02\\
          GetBestAndRemove & 1904 & 112.83\\
          AddToOpen & 1954 & 1.56\\
          SearchInOpen & 18564 & 260.07\\
          RemoveFromOpen & 0 & 0\\
          Replace & 0 & 0\\
          AddToClosed & 1904 & 1.27\\
          SearchInClosed & 18460 & 9524.91\\
          RemoveFromClosed & 0 & 0\\
        \end{tabular}
      }
      \hfil
      \parbox{.45\linewidth}{
        \centering
        \label{tab:tableTieBraking2}
        \caption{Basic A* with tiebraking performance (Path 2)}
        \begin{tabular}{c|c|c}
          \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
          \hline
          A*Pathfinding.Search  & 1 & 21970.11\\
          GetBestAndRemove & 2890 & 282.13\\
          AddToOpen & 3021 & 1.94\\
          SearchInOpen & 28291 & 768.2\\
          RemoveFromOpen & 0 & 0\\
          Replace & 0 & 0\\
          AddToClosed & 2890 & 1.61\\
          SearchInClosed & 27990  & 20761.34\\
          RemoveFromClosed & 0 & 0\\
        \end{tabular}
      }
  \end{table}
  \begin{table}[h!]
    \parbox{.45\linewidth}{
        \centering
        \caption{Basic A* with tiebraking grid information (Path 1)}
        \label{tab:tableA*TiebrakingGrid1}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          1904 & 0.02 & 77\\
        \end{tabular}
    }
    \hfil
    \parbox{.45\linewidth}{
        \centering
        \caption{Basic A* with tiebraking* grid information (Path 2)}
        \label{tab:tableA*TiebrakingGrid2}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          2889 & 0.02 & 133\\
        \end{tabular}
    }
  \end{table}
  \subsection{Comparison}
  Looking at the data from this and the previous algorithm, that there's a little optimization on the data of path 1 even though there's more spent time getting
  the best node from the open set, due to more comparisons. In path 2 we still see an increase on the time for  GetBestAndRemove, but surprisingly there's more time spent
  this may be due to bad measurement of data, since this contradicts what is expected. \\
  
  \section{NodeArray A*}\
  \subsection{Algorithm}
  NodeArray A* is an A* implementation that uses a NodeArray to store the nodes. We use this array as our open and closed set, and we change the status property
  of the nodes when we add them to the open or closed set. This way, we can search for nodes in the open and closed set in constant time.\\
  \subsection{Data}
  \begin{table}[h!]
    \parbox{.45\linewidth}{
      \centering
      \caption{NodeArray A* performance (Path 1)}
      \label{tab:tableNodeArray1}
      \begin{tabular}{c|c|c}
        \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
        \hline
        A*Pathfinding.Search  & 1 & 5.48\\
        GetBestAndRemove & 200 & 1.96\\
        AddToOpen & 232 & 1.13\\
        SearchInOpen & 1044 & 0.04\\
        RemoveFromOpen & 0 & 0\\
        Replace & 0 & 0\\
        AddToClosed & 100  & 0.01\\
        SearchInClosed & 1009 & 0.04\\
        RemoveFromClosed & 0 & 0\\
      \end{tabular}
    }
    \hfil
    \parbox{.45\linewidth}{
      \centering
      \label{tab:tableNodeArray2}
      \caption{NodeArray A* performance (Path 2)}
      \begin{tabular}{c|c|c}
        \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
        \hline
        A*Pathfinding.Search  & 1 & 159.11\\
        GetBestAndRemove & 2890 & 38.36\\
        AddToOpen & 3019 & 9.31\\
        SearchInOpen & 28247 & 1.84\\
        RemoveFromOpen & 0 & 0\\
        Replace & 0 & 0\\
        AddToClosed & 2885 & 0.58\\
        SearchInClosed & 27932  & 1.73\\
        RemoveFromClosed & 0 & 0\\
      \end{tabular}
    }
  \end{table}
  \begin{table}[h!]
    \parbox{.45\linewidth}{
        \centering
        \caption{NodeArray A* grid information (Path 1)}
        \label{tab:tableNodeArrayGrid1}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          1904 & 0.4738739 & 77\\
        \end{tabular}
    }
    \hfil
    \parbox{.45\linewidth}{
        \centering
        \caption{NodeArray A* grid information (Path 2)}
        \label{tab:tableNodeArrayGrid2}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          2884 & 0.4738739 & 135\\
        \end{tabular}
    }
  \end{table}

  \subsection{Comparison}
  NodeArray A* is faster than the previous algorithms, due to the fact that we can search for nodes in the open and closed set in constant time,
  as we can see by the reduction of the SearchInOpen and SearchInClosed time, even tho it spends more time on the AddToOpen due to the use of a PriorityHeap.\\

  \section{NodeArray A* with Goal Bounding}
  \subsection{Algorithm}
  By using precomputation of the grid, we can make bounding boxes for each node and improve the NodeArray A* algorithm. We do this by using djikstra to
  calculate fastest path from each node to all other nodes. This way, we know which direction we should choose when trying to go to a specific node.
  This optimization causes, sometimes, a heavy increase on the starting time, due to the precomputation, but it improves the runtime of the algorithm by a lot.\\ 
  \subsection{Data}
  \begin{table}[h!]
    \parbox{.45\linewidth}{
      \centering
      \caption{NodeArray A* with Goal Bounding performance (Path 1)}
      \label{tab:tableGoalBounding1}
      \begin{tabular}{c|c|c}
        \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
        \hline
        A*Pathfinding.Search  & 1 & 10.62\\
        GetBestAndRemove & 200 & 0.43\\
        AddToOpen & 216 & 0.34\\
        SearchInOpen & 235 & 0\\
        RemoveFromOpen & 0 & 0\\
        Replace & 0 & 0\\
        AddToClosed & 100  & 0.01\\
        SearchInClosed & 126 & 0\\
        RemoveFromClosed & 0 & 0\\
      \end{tabular}
    }
    \hfil
    \parbox{.45\linewidth}{
      \centering
      \caption{NodeArray A* with Goal Bounding performance (Path 2)}
      \label{tab:tableGoalBounding2}
      \begin{tabular}{c|c|c}
        \textbf{Method} & \textbf{Calls} & \textbf{Execution Time (ms)}\\
        \hline
        A*Pathfinding.Search  & 1 & 17.12\\
        GetBestAndRemove & 158 & 0.40\\
        AddToOpen & 165 & 0.35\\
        SearchInOpen & 388 & 0.01\\
        RemoveFromOpen & 0 & 0\\
        Replace & 0 & 0\\
        AddToClosed & 158 & 0.03\\
        SearchInClosed & 282 & 0.01\\
        RemoveFromClosed & 0 & 0\\
      \end{tabular}
    }
  \end{table}
  \begin{table}[h!]
    \parbox{.45\linewidth}{
        \centering
        \caption{NodeArray A* with Goal Bounding grid information (Path 1)}
        \label{tab:tableGoalBoundingGrid1}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          228 & 0.1092952 & 9\\
        \end{tabular}
    }
    \hfil
    \parbox{.45\linewidth}{
        \centering
        \caption{NodeArray A* with Goal Bounding grid information (Path 2)}
        \label{tab:tableGoalBoundingGrid2}
        \begin{tabular}{c|c|c}
          \textbf{TotalPNodes} & \textbf{TotalPTime} & \textbf{MaxOpenNodes}\\
          \hline
          157 & 0.4738739 & 8\\
        \end{tabular}
    }
  \end{table}

  \subsection{Comparison}
  Comparing this data with the previous ones, we can see that this is by far the best optimization in terms of runtime. This is due to the use of bounding boxes,
  that shorten the amounts of nodes we process, and thus the amount of calls to add, remove and search in the open and closed set.\\

  \section{Bonus Level}
  \section{Conclusions}
  We can infer that A* is pretty slow when compared to it's otimizations. \\
  Also, we can notice that adding pre-processing to the algorithm can improve it's runtime by a lot, 
  even though it takes some time to do it.
\end{document}